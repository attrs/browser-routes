{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a37a721262cba4d6a7db","webpack:///./routes.js","webpack:///(webpack)/~/node-libs-browser/~/path-browserify/index.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./web_modules/route-pattern/route-pattern.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/index.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/decode.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/encode.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,+CAA+C;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qD;AACA,sD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;;AAEA;AACA;AACA,MAAK,GAAG;;AAER;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,GAAG;;AAEZ;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,uBAAuB;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,QAAO;AACP;AACA,0BAAyB,iBAAiB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;ACxnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACtHtC;;AAEA;AACA;AACA;AACA,WAAU,WAAW,GAAG,KAAK,GAAG,KAAK,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB,qBAAoB;AACpB;AACA,2BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjXA;;AAEA;AACA;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"routes.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Routes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Routes\"] = factory();\n\telse\n\t\troot[\"Routes\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a37a721262cba4d6a7db\n **/","var path = require('path');\nvar RoutePattern = require('route-pattern');\n\n/*\n(function() {\n  var defined = '/hello/:planet?foo=:foo&fruit=:fruit#:section';\n  var url = '/hello/earth?foo=bar&fruit=apple#chapter2';\n  var pattern = RoutePattern.fromString(defined);\n  var matches = pattern.matches(url);\n  var params = pattern.match(url);\n  \n  console.log('match', matches);\n  console.log(JSON.stringify(params, null, '  '));\n});\n*/\n\nfunction normalize(url, doc) {\n  if( !url || typeof url !== 'string' ) throw new TypeError('illegal url');\n  var a = (doc || document).createElement('a');\n  a.href = url;\n  return {\n    href: a.href,\n    protocol: a.protocol,\n    hostname: a.hostname,\n    port: a.port,\n    pathname: a.pathname,\n    fullpath: a.pathname + (a.search ? a.search : '') + (a.hash ? a.hash : ''),\n    search: a.search,\n    hash: a.hash,\n    host: a.host\n  };\n}\n\nfunction config(name, alt) {\n  var root = document.head.querySelector('meta[name=\"' + name + '\"][content]');\n  return (root && root.getAttribute('content')) || alt;\n}\n\nfunction current(mode) {\n  if( mode === 'hash' ) {\n    return location.hash;\n  }\n\n  return location.href;\n}\n\nfunction endsWith(str, word) {\n  var i = str.toLowerCase().indexOf(word);\n  return i > 0 && i === str.length - word.length;\n}\n\nfunction parseQuery(query) {\n  query = query.trim();\n  if( query[0] === '?' ) query = query.substring(1);\n  var match,\n      pl     = /\\+/g,\n      search = /([^&=]+)=?([^&]*)/g,\n      decode = function (s) { return decodeURIComponent(s.replace(pl, \" \")); };\n      \n  var params = {};\n  while (match = search.exec(query)) {\n    var key = decode(match[1]);\n    var value = decode(match[2]);\n    if( Array.isArray(params[key]) ) params[key].push(value);\n    else if( params[key] ) (params[key] = [params[key]]).push(value);\n    else params[key] = value;\n  }\n  return params;\n}\n\nfunction defaultChecker() {\n  var tag = document.currentScript || document._currentScript;\n  return function() {\n    return tag && tag.ownerDocument && tag.ownerDocument.documentElement && tag.ownerDocument.documentElement.contains(tag);\n  };\n}\n\nfunction addEventListener(scope, type, fn, bubble) { \n  if( scope.attachEvent ) scope.attachEvent(type,fn); \n  else scope.addEventListener(type,fn,bubble);\n}\n\nfunction patternize(source, ignoresubdir) {\n  var pettern = RoutePattern.fromString(source);\n  var ap = RoutePattern.fromString(source + '/*after');\n  \n  return {\n    match: function(url) {\n      if( source === '/' ) return ignoresubdir ? true : (source === url);\n      \n      if( pettern.matches(url) ) {\n        return pettern.match(url).namedParams;\n      } else if( ignoresubdir && ap.matches(url) ) {\n        var params = ap.match(url).namedParams;\n        delete params.after;\n        return params;\n      }\n      return false;\n    },\n    matches: function(url) {\n      return pattern.matches(url) ? true : (ignoresubdir && ap.matches(url) ? true : false);\n    }\n  };\n}\n\nfunction dividepath(axis, full) {\n  if( axis[0] === '/' ) axis = axis.substring(1);\n  if( full[0] === '/' ) full = full.substring(1);\n  if( endsWith(axis, '/') ) axis = axis.substring(0, axis.length - 1);\n  if( endsWith(full, '/') ) full = full.substring(0, full.length - 1);\n  if( !axis ) return {\n    sub: '/' + full,\n    parent: '/'\n  };\n  \n  while(~axis.indexOf('//')) axis.split('//').join('/');\n  while(~full.indexOf('//')) full.split('//').join('/');\n  \n  axis = axis.split('/');\n  full = full.split('/');\n  var sub = [], parent = [];\n  \n  for(var i=0; i < full.length; i++) {\n    if( axis[i] && axis[i][0] !== ':' &&  full[i] !== axis[i] ) return null;\n    \n    if( i >= axis.length ) sub.push(full[i]);\n    else parent.push(full[i]);\n  }\n  \n  return {\n    parent: '/' + parent.join('/'),\n    sub: '/' + sub.join('/')\n  };\n}\n\n/*\nconsole.log('/', subpath('/', '/system/user/list'));\nconsole.log('/system', subpath('/system', '/system/user/list'));\nconsole.log('/system/user', subpath('/system/user', '/system/user/list'));\nconsole.log('/system/user/list', subpath('/system/user/list', '/system/user/list'));\nconsole.log('/:a', subpath('/:a', '/system/user/list'));\nconsole.log('/:a/:b', subpath('/:a/:b', '/system/user/list'));\nconsole.log('/:a/:b/:c', subpath('/:a/:b/:c', '/system/user/list'));\n\nvar p = patternize('/', true);\nconsole.log('/a/b/c', p.match('/a/b/c'));\n*/\n\nfunction capture(o) {\n  return JSON.parse(JSON.stringify(o));\n}\n\nfunction redirector(url) {\n  return function redirector(req, res, next) {\n    res.redirect(url);\n  };\n}\n\nfunction mix() {\n  var result = {};\n  [].forEach.call(arguments, function(o) {\n    if( o && typeof o === 'object' ) {\n      for(var k in o ) result[k] = o[k];\n    }\n  });\n  return result;\n}\n\n\n// factory Router\nfunction Router(id) {\n  id = id || 'unknwon';\n  var boot = true;\n  var routes = [];\n  var listeners = {};\n  \n  var body = function Router(req, res, next) {\n    //console.log('router', req.url);\n    if( !req.url || req.url[0] !== '/' ) throw new Error('illegal url: ' + req.url);\n    \n    next = next || function() {};\n    \n    //console.log('body', req.baseUrl, req.url);\n    var fns = [];\n    routes.forEach(function(route) {\n      //console.log('[' + name + '] route', route);\n      if( route.type === 'boot' ) {\n        if( boot ) fns.push(route);\n        return;\n      }\n      \n      //console.log(route.path, req.url, route.pattern.match(req.url));\n      var params = route.pattern.match(req.url);\n      if( params ) return fns.push({\n        type: route.type,\n        fn: route.fn,\n        path: route.path,\n        pattern: route.pattern,\n        params: params\n      });\n    });\n    \n    if( !fns.length ) return next();\n    \n    /*console.info('[' + name + '] fns', req.url, fns.map(function(o) {\n      return (o.path || 'any') + '(' + (o.fn.name || 'unnamed') + ')';\n    }));*/\n    \n    req.boot = boot;\n    boot = false;\n    \n    var oParentUrl = req.parentUrl || '';\n    var oUrl = req.url;\n    var oParams = req.params || {};\n    var i = 0;\n    var forward = function(err) {\n      req.params = oParams;\n      req.parentUrl = oParentUrl;\n      req.url = oUrl;\n      \n      var route = fns[i++];\n      if( !route ) return next(err);\n      \n      var div = dividepath(route.path || '', req.url);\n      req.params = mix(oParams, route.params);\n      \n      if( route.fn.__router__ ) {\n        req.url = div.sub;\n        req.parentUrl = path.join(oParentUrl, div.parent);\n        /*console.log('routing', capture({\n          //type: type,\n          //id: route.fn.id,\n          path: route.path,\n          url: req.url,\n          parentUrl: req.parentUrl,\n          oParentUrl: oParentUrl,\n          oUrl: oUrl\n        }));*/\n        \n        route.fn.apply(body, [req, res, forward]);\n      } else {\n        route.fn.apply(body, [req, res, forward]);\n      }\n    };\n    forward();\n  };\n  \n  body.id = id;\n  body.__router__ = true;\n  body.exists = function(url) {\n    var exists = false;\n    routes.forEach(function(route) {\n      if( exists ) return;\n      if( route.type === 'get' ) {\n        var params = route.pattern.match(url);\n        if( params ) exists = true;\n      } else if( route.type === 'use' ) {\n        exists = route.fn.exists(url.substring(route.path.length));\n      }\n    });\n    return exists;\n  };\n  \n  body.use = function(path, fn) {\n    if( typeof path === 'function' ) fn = path, path = '/';\n    if( typeof path !== 'string' ) throw new TypeError('illegal type of path:' + typeof(path));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    path = path ? path.trim() : '/';\n    if( path[0] !== '/' ) path = '/' + path;\n    \n    routes.push({\n      type: 'use',\n      path: path,\n      pattern: patternize(path, true),\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.get = function(path, fn) {\n    if( typeof path === 'function' ) fn = path, path = '/';\n    if( typeof path !== 'string' ) throw new TypeError('illegal type of path:' + typeof(path));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    path = path ? path.trim() : '/';\n    if( path[0] !== '/' ) path = '/' + path;\n    \n    routes.push({\n      type: 'get',\n      path: path,\n      pattern: patternize(path),\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.boot = function(fn) {\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    routes.push({\n      type: 'boot',\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.notfound = function(fn) {\n    body.on('notfound', fn);\n    return this;\n  };\n  \n  body.error = function(fn) {\n    body.on('error', fn);\n    return this;\n  };\n  \n  body.drop = function(fn) {\n    var dropfns = [];\n    routes.forEach(function(route) {\n      if( route.fn === fn ) dropfns.push(route);\n    });\n    \n    dropfns.forEach(function(route) {\n      routes.splice(routes.indexOf(route), 1);\n    });\n    return this;\n  };\n  \n  body.clear = function() {\n    routes = [];\n    return this;\n  };\n  \n  body.on = function(type, fn) {\n    listeners[type] = listeners[type] || [];\n    listeners[type].push(fn);\n    return this;\n  };\n  \n  body.once = function(type, fn) {\n    var wrap = function(e) {\n      body.off(type, wrap);\n      return fn.call(this, e);\n    };\n    body.on(type, wrap);\n    return this;\n  };\n\n  body.off = function(type, fn) {\n    var fns = listeners[type];\n    if( fns )\n      for(var i;~(i = fns.indexOf(fn));) fns.splice(i, 1);\n    \n    return this;\n  };\n\n  body.fire = function(type, detail) {\n    if( type === 'error' && !(listeners[type] && isteners[type].length) )\n      return console.error('[routes] error', detail);\n    \n    (listeners[type] || []).forEach(function(listener) {\n      listener.call(this, {\n        type: type,\n        detail: detail || {}\n      });\n    });\n  };\n  \n  return body;\n}\n\n// class Routes\nfunction Routes(options) {\n  if( !(this instanceof Routes) ) throw new Error('illegal state: \\'new Routes()\\' instead of \\'Routes()\\'');\n  \n  options = options || {};\n  \n  var self = this;\n  var baseURL = '';\n  var router = Router('root'), request, response, hashroutes;\n  \n  //console.info('baseURL', baseURL);\n  \n  this.config = function(key, value) {\n    var o = options;\n    if( arguments.length === 1 ) return o(key);\n    if( value === null ) delete o[key];\n    else o[key] = value;\n    return this;\n  };\n  \n  this.base = function(url) {\n    if( !arguments.length ) return baseURL;\n    if( !url ) {\n      baseURL = '';\n      return this;\n    }\n    baseURL = path.dirname(path.resolve(url, 'index.html'));\n    //console.log('baseURL', baseURL);\n    return this;\n  };\n  \n  this.router = function(name) {\n    return Router(name);\n  };\n  \n  this.normalize = function(url) {\n    url = url.trim();\n    if( !url ) return baseURL;\n    if( url[0] === '/' ) return baseURL + url;\n    return normalize(url).fullpath;\n  };\n  \n  var exec = this.exec = function(requrl) {\n    //console.info('exec', requrl);\n    var parsed = normalize(requrl);\n    var hash = parsed.hash;\n    var query = parsed.search;\n    var url = parsed.pathname;\n    var fullpath = parsed.fullpath;\n    if( request && request.requestURL && fullpath === request.requestURL ) return;\n    \n    //console.log('exec', baseURL, requrl, url, url.indexOf(baseURL), parsed);\n    if( baseURL && url.startsWith(baseURL) ) {\n      url = url.substring(baseURL.length);\n    } else if( baseURL ){\n      return console.error('given url is not a sub url of base url \\'' + baseURL + '\\'');\n    }\n    \n    hashroutes = [];\n    request = {\n      method: 'get',\n      parsed: parsed,\n      baseURL: baseURL,\n      requestURL: fullpath,\n      url: url || '/',\n      hashname: hash,\n      query: parseQuery(query),\n      params: {}\n    };\n    \n    //console.log('req', capture(request));\n    \n    response = {\n      redirect: function(tourl) {\n        //console.info('redirect', url, request.parentUrl, request.url, request);\n        if( tourl.startsWith('#') ) {\n          location.href = tourl;\n        } else if( tourl.startsWith('/') ) {\n          exec(path.join(baseURL, tourl));\n        } else {\n          exec(path.join(baseURL, request.parentUrl, request.url, tourl));\n        }\n        \n        router.fire('redirect', {\n          requestURL: fullpath,\n          url: url,\n          request: request,\n          response: response\n        });\n        \n        return this;\n      },\n      hash: function(hash, fn) {\n        hashroutes.push({hash:hash, fn:fn});\n      }\n    };\n    \n    router.fire('request', {\n      requestURL: fullpath,\n      url: url,\n      request: request,\n      response: response\n    });\n    \n    router(request, response);\n    return this;\n  };\n  \n  this.exechash = function() {\n    // TODO: hash 변경. 현재 request 의 hash 를 라우팅한다.\n    return this;\n  };\n  \n  // --- wire to router\n  this.use = function(path, fn) {\n    router.use.apply(router, arguments);\n    return this;\n  };\n  \n  this.boot = function(fn) {\n    router.boot(fn);\n    return this;\n  };\n  \n  this.get = function(path, fn) {\n    router.get(path, fn);\n    return this;\n  };\n  \n  this.notfound = function(fn) {\n    router.notfound(fn);\n    return this;\n  };\n  \n  this.error = function(fn) {\n    router.error(fn);\n    return this;\n  };\n  \n  this.drop = function(fn) {\n    router.drop(fn);\n    return this;\n  };\n  \n  this.exists = function(path) {\n    return router.exists(path);\n  };\n  \n  this.clear = function() {\n    router.clear();\n    return this;\n  };\n  \n  this.on = function(type, fn) {\n    router.on(type, fn);\n    return this;\n  };\n  \n  this.once = function(type, fn) {\n    router.once(type, fn);\n    return this;\n  };\n  \n  this.off = function(type, fn) {\n    router.off(type, fn);\n    return this;\n  };\n}\n\nvar routes = new Routes();\nroutes.Routes = Routes;\nroutes.Router = Router;\n\n// instantiate main routes && trigger\n(function() {\n  //var always = config('routes.always') === 'true' ? true : true;\n  var mode = config('routes.mode') || (history.pushState ? 'pushstate' : 'hash');\n  \n  if( mode === 'pushstate' ) {\n    if( !history.pushState ) return console.error('[routes] unsupported \\'history.pushState\\'');\n    \n    var _pushState = history.pushState;\n    history.pushState = function(state, title, url) {\n      _pushState.apply(history, arguments);\n      routes.exec(location.href);\n    };\n    \n    window.onpopstate = function(e) {\n      routes.exec(location.href);\n    };\n    \n    routes.on('request', function(e) {\n      if( normalize(location.href).fullpath !== normalize(e.detail.requestURL).fullpath ) {\n        _pushState.call(history, null, null, e.detail.requestURL);\n      }\n    });\n    \n    routes.href = function(url) {\n      history.pushState(null, null, routes.normalize(url));\n    };\n  } else if( mode === 'hash' ) {\n    if( !('onhashchange' in window) ) return console.error('[routes] unsupported \\'onhashchange\\'');\n    \n    addEventListener(window, 'hashchange', function() {\n      routes.exec(location.hash);\n    });\n    \n    routes.on('redirect', function(e) {\n      location.href = '#' + e.detail.url;\n    });\n    \n    routes.href = function(url) {\n      location.href = '#' + routes.normalize(url);\n    };\n  }\n  \n  var observer;\n  function bootup() {\n    function routify(a) {\n      if( !a.__routes_managed__ ) {\n        a.__routes_managed__ = true;\n        addEventListener(a, 'click', function(e) {\n          e.preventDefault();\n          routes.href(a.getAttribute('href'));\n        });\n      }\n      return this;\n    }\n  \n    function scan() {\n      [].forEach.call(document.querySelectorAll('[routes], [data-routes]'), routify);\n      return this;\n    }\n    \n    // observe anchor tags\n    if( observer ) observer.disconnect();\n    observer = new MutationObserver(function(mutations) {\n      mutations.forEach(function(mutation) {\n        [].forEach.call(mutation.addedNodes, function(node) {\n          if( node.nodeType === 1 ) {\n            if( node.hasAttribute('routes') ) routify(node);\n            if( node.hasAttribute('data-routes') ) routify(node);\n            if( node.querySelectorAll ) [].forEach.call(node.querySelectorAll('[routes], [data-routes]'), routify);\n          }\n        });\n      });\n    });\n    \n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    scan();\n    routes.exec(location.href);\n  }\n  \n  if( document.body ) bootup();\n  else addEventListener(document, 'DOMContentLoaded', bootup);\n})();\n\nmodule.exports = routes;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./routes.js\n ** module id = 0\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","var querystring = require(\"querystring\");\n\n// # Utility functions\n//\n// ## Shallow merge two or more objects, e.g.\n// merge({a: 1, b: 2}, {a: 2}, {a: 3}) => {a: 3, b: 2}\nfunction merge() {\n  return [].slice.call(arguments).reduce(function (merged, source) {\n    for (var prop in source) {\n      merged[prop] = source[prop];\n    }\n    return merged;\n  }, {});\n}\n\n// Split a location string into different parts, e.g.:\n// splitLocation(\"/foo/bar?fruit=apple#some-hash\") => {\n//  path: \"/foo/bar\", queryString: \"fruit=apple\", hash: \"some-hash\" \n// }\nfunction splitLocation(location) {\n  var re = /([^\\?#]*)?(\\?[^#]*)?(#.*)?$/;\n  var match = re.exec(location);\n  return {\n    path: match[1] || '',\n    queryString: match[2] && match[2].substring(1) || '',\n    hash: match[3] && match[3].substring(1) || ''\n  }\n}\n\n// # QueryStringPattern\n// The QueryStringPattern holds a compiled version of the query string part of a route string, i.e.\n// ?foo=:foo&fruit=:fruit\nvar QueryStringPattern = (function () {\n\n  // The RoutePattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function QueryStringPattern(options) {\n\n    // The query parameters specified\n    this.params = options.params;\n\n    // if allowWildcards is set to true, unmatched query parameters will be ignored\n    this.allowWildcards = options.allowWildcards;\n\n    // The original route string (optional)\n    this.routeString = options.routeString;\n  }\n\n  QueryStringPattern.prototype.matches = function (queryString) {\n    var givenParams = (queryString || '').split(\"&\").reduce(function (params, pair) {\n      var parts = pair.split(\"=\"),\n        name = parts[0],\n        value = parts[1];\n      if (name) params[name] = value;\n      return params;\n    }, {});\n\n    var requiredParam, requiredParams = [].concat(this.params);\n    while (requiredParam = requiredParams.shift()) {\n      if (!givenParams.hasOwnProperty(requiredParam.key)) return false;\n      if (requiredParam.value && givenParams[requiredParam.key] != requiredParam.value) return false;\n    }\n    if (!this.allowWildcards && this.params.length) {\n      if (Object.getOwnPropertyNames(givenParams).length > this.params.length) return false;\n    }\n    return true;\n  };\n\n  QueryStringPattern.prototype.match = function (queryString) {\n\n    if (!this.matches(queryString)) return null;\n\n    var data = {\n      params: [],\n      namedParams: {},\n      namedQueryParams: {}\n    };\n\n    if (!queryString) {\n      return data;\n    }\n\n    // Create a mapping from each key in params to their named param\n    var namedParams = this.params.reduce(function (names, param) {\n      names[param.key] = param.name;\n      return names;\n    }, {});\n\n    var parsedQueryString = querystring.parse(queryString);\n    Object.keys(parsedQueryString).forEach(function(key) {\n      var value = parsedQueryString[key];\n      data.params.push(value);\n      if (namedParams[key]) {\n        data.namedQueryParams[namedParams[key]] = data.namedParams[namedParams[key]] = value;\n      }\n    });\n    return data;\n  };\n\n  QueryStringPattern.fromString = function (routeString) {\n\n    var options = {\n      routeString: routeString,\n      allowWildcards: false,\n      params: []\n    };\n\n    // Extract named parameters from the route string\n    // Construct an array with some metadata about each of the named parameters\n    routeString.split(\"&\").forEach(function (pair) {\n      if (!pair) return;\n\n      var parts = pair.split(\"=\"),\n        name = parts[0],\n        value = parts[1] || '';\n\n      var wildcard = false;\n\n      var param = { key: name };\n\n      // Named parameters starts with \":\"\n      if (value.charAt(0) == ':') {\n        // Thus the name of the parameter is whatever comes after \":\"\n        param.name = value.substring(1);\n      }\n      else if (name == '*' && value == '') {\n        // If current param is a wildcard parameter, the options are flagged as accepting wildcards\n        // and the current parameter is not added to the options' list of params\n        wildcard = options.allowWildcards = true;\n      }\n      else {\n        // The value is an exact match, i.e. the route string \n        // page=search&q=:query will match only when the page parameter is \"search\"\n        param.value = value;\n      }\n      if (!wildcard) {\n        options.params.push(param);\n      }\n    });\n    return new QueryStringPattern(options);\n  };\n\n  return QueryStringPattern;\n})();\n\n// # PathPattern\n// The PathPattern holds a compiled version of the path part of a route string, i.e.\n// /some/:dir\nvar PathPattern = (function () {\n\n  // These are the regexps used to construct a regular expression from a route pattern string\n  // Based on route patterns in Backbone.js\n  var\n    pathParam = /:\\w+/g,\n    splatParam = /\\*\\w+/g,\n    namedParams = /(:[^\\/\\.]+)|(\\*\\w+)/g,\n    subPath = /\\*/g,\n    escapeRegExp = /[-[\\]{}()+?.,\\\\^$|#\\s]/g;\n\n  // The PathPattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function PathPattern(options) {\n    // The route string are compiled to a regexp (if it isn't already)\n    this.regexp = options.regexp;\n\n    // The query parameters specified in the path part of the route\n    this.params = options.params;\n\n    // The original routestring (optional)\n    this.routeString = options.routeString;\n  }\n\n  PathPattern.prototype.matches = function (pathname) {\n    return this.regexp.test(pathname);\n  };\n\n  // Extracts all matched parameters\n  PathPattern.prototype.match = function (pathname) {\n\n    if (!this.matches(pathname)) return null;\n    \n    // The captured data from pathname\n    var data = {\n      params: [],\n      namedParams: {}\n    };\n\n    // Using a regexp to capture named parameters on the pathname (the order of the parameters is significant)\n    (this.regexp.exec(pathname) || []).slice(1).forEach(function (value, idx) {\n      if(value !== undefined) {\n        value = decodeURIComponent(value);\n      }\n\n      data.namedParams[this.params[idx]] = value;\n      data.params.push(value);\n    }, this);\n\n    return data;\n  };\n\n  PathPattern.routePathToRegexp = function (path) {\n    path = path\n      .replace(escapeRegExp, \"\\\\$&\")\n      .replace(pathParam, \"([^/]+)\")\n      .replace(splatParam, \"(.*)?\")\n      .replace(subPath, \".*?\")\n      .replace(/\\/?$/, \"/?\");\n    return new RegExp(\"^/?\" + path + \"$\");\n  };\n\n  // This compiles a route string into a set of options which a new PathPattern is created with \n  PathPattern.fromString = function (routeString) {\n\n    // Whatever comes after ? and # is ignored\n    routeString = routeString.split(/\\?|#/)[0];\n\n    // Create the options object\n    // Keep the original routeString and a create a regexp for the pathname part of the url\n    var options = {\n      routeString: routeString,\n      regexp: PathPattern.routePathToRegexp(routeString),\n      params: (routeString.match(namedParams) || []).map(function (param) {\n        return param.substring(1);\n      })\n    };\n\n    // Options object are created, now instantiate the PathPattern\n    return new PathPattern(options);\n  };\n\n  return PathPattern;\n}());\n\n// # RegExpPattern\n// The RegExpPattern is just a simple wrapper around a regex, used to provide a similar api as the other route patterns\nvar RegExpPattern = (function () {\n  // The RegExpPattern constructor\n  // Wraps a regexp and provides a *Pattern api for it\n  function RegExpPattern(regex) {\n    this.regex = regex;\n  }\n\n  RegExpPattern.prototype.matches = function (loc) {\n    return this.regex.test(loc);\n  };\n\n  // Extracts all matched parameters\n  RegExpPattern.prototype.match = function (location) {\n\n    if (!this.matches(location)) return null;\n\n    var loc = splitLocation(location);\n\n    return {\n      params: this.regex.exec(location).slice(1),\n      queryParams: querystring.parse(loc.queryString),\n      namedParams: {}\n    };\n  };\n\n  return RegExpPattern;\n}());\n\n// # RoutePattern\n// The RoutePattern combines the PathPattern and the QueryStringPattern so it can represent a full location\n// (excluding the scheme + domain part)\n// It also allows for having path-like routes in the hash part of the location\n// Allows for route strings like:\n// /some/:page?param=:param&foo=:foo#:bookmark\n// /some/:page?param=:param&foo=:foo#/:section/:bookmark\n// \n// Todo: maybe allow for parameterization of the kind of route pattern to use for the hash?\n// Maybe use the QueryStringPattern for cases like\n// /some/:page?param=:param&foo=:foo#?onlyCareAbout=:thisPartOfTheHash&*\n// Need to test how browsers handles urls like that\nvar RoutePattern = (function () {\n\n  // The RoutePattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function RoutePattern(options) {\n    // The route string are compiled to a regexp (if it isn't already)\n    this.pathPattern = options.pathPattern;\n    this.queryStringPattern = options.queryStringPattern;\n    this.hashPattern = options.hashPattern;\n\n    // The original routestring (optional)\n    this.routeString = options.routeString;\n  }\n\n  RoutePattern.prototype.matches = function (location) {\n    // Whatever comes after ? and # is ignored\n    var loc = splitLocation(location);\n\n    return (!this.pathPattern || this.pathPattern.matches(loc.path)) &&\n      (!this.queryStringPattern || this.queryStringPattern.matches(loc.queryString) ) &&\n      (!this.hashPattern || this.hashPattern.matches(loc.hash))\n  };\n\n  // Extracts all matched parameters\n  RoutePattern.prototype.match = function (location) {\n\n    if (!this.matches(location)) return null;\n\n    // Whatever comes after ? and # is ignored\n    var loc = splitLocation(location),\n      match,\n      pattern;\n\n    var data = {\n      params: [],\n      namedParams: {},\n      pathParams: {},\n      queryParams: querystring.parse(loc.queryString),\n      namedQueryParams: {},\n      hashParams: {}\n    };\n\n    var addMatch = function (match) {\n      data.params = data.params.concat(match.params);\n      data.namedParams = merge(data.namedParams, match.namedParams);\n    };\n\n    if (pattern = this.pathPattern) {\n      match = pattern.match(loc.path);\n      if (match) addMatch(match);\n      data.pathParams = match ? match.namedParams : {};\n    }\n    if (pattern = this.queryStringPattern) {\n      match = pattern.match(loc.queryString);\n      if (match) addMatch(match);\n      data.namedQueryParams = match ? match.namedQueryParams : {};\n    }\n    if (pattern = this.hashPattern) {\n      match = pattern.match(loc.hash);\n      if (match) addMatch(match);\n      data.hashParams = match ? match.namedParams : {};\n    }\n    return data;\n  };\n\n  // This compiles a route string into a set of options which a new RoutePattern is created with \n  RoutePattern.fromString = function (routeString) {\n    var parts = splitLocation(routeString);\n\n    var matchPath = parts.path;\n    var matchQueryString = parts.queryString || routeString.indexOf(\"?\") > -1;\n    var matchHash = parts.hash || routeString.indexOf(\"#\") > -1;\n\n    // Options object are created, now instantiate the RoutePattern\n    return new RoutePattern({\n      pathPattern: matchPath && PathPattern.fromString(parts.path),\n      queryStringPattern: matchQueryString && QueryStringPattern.fromString(parts.queryString),\n      hashPattern: matchHash && PathPattern.fromString(parts.hash),\n      routeString: routeString\n    });\n  };\n\n  return RoutePattern;\n}());\n\n// CommonJS export\nmodule.exports = RoutePattern;\n\n// Also export the individual pattern classes\nRoutePattern.QueryStringPattern = QueryStringPattern;\nRoutePattern.PathPattern = PathPattern;\nRoutePattern.RegExpPattern = RegExpPattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./web_modules/route-pattern/route-pattern.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/index.js\n ** module id = 4\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/decode.js\n ** module id = 5\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/encode.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}