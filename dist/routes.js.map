{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d000568be0b4ed4b6eed","webpack:///./routes.js","webpack:///(webpack)/~/node-libs-browser/~/path-browserify/index.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,+CAA+C;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qD;AACA,sD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK,GAAG;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAA+E;AAC/E;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,uBAAuB;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,QAAO;AACP;AACA,0BAAyB,iBAAiB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;AC7gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU","file":"routes.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Routes\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Routes\"] = factory();\n\telse\n\t\troot[\"Routes\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d000568be0b4ed4b6eed\n **/","var path = require('path');\n\nfunction normalize(url, doc) {\n  if( !url || typeof url !== 'string' ) throw new TypeError('illegal url');\n  var a = (doc || document).createElement('a');\n  a.href = url;\n  return {\n    href: a.href,\n    protocol: a.protocol,\n    hostname: a.hostname,\n    port: a.port,\n    pathname: a.pathname,\n    fullpath: a.pathname + (a.search ? a.search : '') + (a.hash ? a.hash : ''),\n    search: a.search,\n    hash: a.hash,\n    host: a.host\n  };\n}\n\nfunction config(name, alt) {\n  var root = document.head.querySelector('meta[name=\"' + name + '\"][content]');\n  return (root && root.getAttribute('content')) || alt;\n}\n\nfunction current(mode) {\n  if( mode === 'hash' ) {\n    return location.hash;\n  }\n\n  return location.href;\n}\n\nfunction endsWith(str, word) {\n  var i = str.toLowerCase().indexOf(word);\n  return i > 0 && i === str.length - word.length;\n}\n\nfunction parseQuery(query) {\n  query = query.trim();\n  if( query[0] === '?' ) query = query.substring(1);\n  var match,\n      pl     = /\\+/g,\n      search = /([^&=]+)=?([^&]*)/g,\n      decode = function (s) { return decodeURIComponent(s.replace(pl, \" \")); };\n      \n  var params = {};\n  while (match = search.exec(query)) {\n    var key = decode(match[1]);\n    var value = decode(match[2]);\n    if( Array.isArray(params[key]) ) params[key].push(value);\n    else if( params[key] ) (params[key] = [params[key]]).push(value);\n    else params[key] = value;\n  }\n  return params;\n}\n\nfunction defaultChecker() {\n  var tag = document.currentScript || document._currentScript;\n  return function() {\n    return tag && tag.ownerDocument && tag.ownerDocument.documentElement && tag.ownerDocument.documentElement.contains(tag);\n  };\n}\n\nfunction addEventListener(scope, type, fn, bubble) { \n  if( scope.attachEvent ) scope.attachEvent(type,fn); \n  else scope.addEventListener(type,fn,bubble);\n}\n\nfunction match(requri, uri) {\n  //TODO: fix regexp matching\n  return requri === uri;\n}\n\nfunction capture(o) {\n  return JSON.parse(JSON.stringify(o));\n}\n\nfunction chain(scope, req, res, routes, next) {\n  var i = 0, forward;\n  return forward = function(err) {\n    var route = routes[i++];\n    if( err || !route ) return next(err);\n    \n    var uri = route.uri;\n    var type = route.type;\n    var fn = route.fn;\n    \n    //console.log('current', uri, type, fn);\n    if( type === 'use' && uri ) {\n      if( uri && uri.trim() === '/' ) uri = '';\n      \n      var opurl = req.purl || '';\n      var ourl = req.url;\n      req.purl = path.join(opurl, ourl.substring(0, uri.length));\n      req.url = ourl.substring(uri.length) || '/';\n      \n      //console.log('routing', uri, ourl, req.purl, req.url);\n      \n      fn.apply(scope, [req, res, forward]);\n      req.purl = opurl;\n      req.url = ourl;\n    } else {\n      fn.apply(scope, [req, res, forward]);\n    }\n  };\n}\n\nfunction redirector(uri) {\n  return function redirector(req, res, next) {\n    res.redirect(uri);\n  };\n}\n\n\n// factory Router\nfunction Router(name) {\n  name = name || 'unknwon';\n  var boot = true;\n  var routes = [];\n  var listeners = {};\n  \n  var body = function Router(req, res, next) {\n    next = next || function() {};\n    \n    //console.log('body', req.baseUrl, req.url);\n    var fns = [];\n    routes.forEach(function(route) {\n      //console.log('[' + name + '] route', route);\n      if( !boot && route.boot ) return;\n      if( route.type === 'use' ) {\n        if( route.uri === '/' || !req.url.indexOf(route.uri) || match(req.url, route.uri) ) return fns.push(route);\n      } else if( route.type === 'get' ) {\n        //console.log(name, req.url || '(no)', route.uri || '(no)');\n        if( match(req.url, route.uri) ) return fns.push(route);\n      }\n    });\n    \n    /*console.info('[' + name + '] fns', req.url, fns.map(function(o) {\n      return (o.uri || 'any') + '(' + (o.fn.name || 'unnamed') + ')';\n    }));*/\n    \n    req.boot = boot;\n    chain(body, req, res, fns, next)(req.error);\n    boot = false;\n  };\n  \n  body.exists = function(url) {\n    var exists = false;\n    routes.forEach(function(route) {\n      //console.log('exists', url, route.uri);\n      if( route.type === 'get' && match(url, route.uri) ) return exists = true;\n      else if( route.type === 'use' && route.uri && !url.indexOf(route.uri) ) { // middleware 는 포함하지 않음\n        if( typeof route.fn.exists !== 'function' ) return exists = match(url, route.uri);\n        exists = route.fn.exists(url.substring(route.uri.length));\n      }\n    });\n    return exists;\n  };\n  \n  body.use = function(uri, fn) {\n    if( typeof uri === 'function' ) fn = uri, uri = null;\n    if( uri && typeof uri !== 'string' ) throw new TypeError('illegal type of uri:' + typeof(uri));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    //if( uri && !endsWith(uri, '/') ) uri = uri + '/';\n    uri = uri ? uri.trim() : '/';\n    if( uri[0] !== '/' ) uri = '/' + uri;\n    \n    routes.push({\n      type: 'use',\n      uri: uri,\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.get = function(uri, fn) {\n    if( typeof uri !== 'string' ) throw new TypeError('illegal type of uri:' + typeof(uri));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    uri = uri ? uri.trim() : '/';\n    if( uri[0] !== '/' ) uri = '/' + uri;\n    \n    routes.push({\n      type: 'get',\n      uri: uri,\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.boot = function(fn) {\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    routes.push({\n      type: 'use',\n      boot: true,\n      fn: fn\n    });\n    return this;\n  };\n  \n  body.notfound = function(fn) {\n    body.on('notfound', fn);\n    return this;\n  };\n  \n  body.error = function(fn) {\n    body.on('error', fn);\n    return this;\n  };\n  \n  body.drop = function(fn) {\n    var dropfns = [];\n    routes.forEach(function(route) {\n      if( route.fn === fn ) dropfns.push(route);\n    });\n    \n    dropfns.forEach(function(route) {\n      routes.splice(routes.indexOf(route), 1);\n    });\n    return this;\n  };\n  \n  body.clear = function() {\n    routes = [];\n    return this;\n  };\n  \n  body.on = function(type, fn) {\n    listeners[type] = listeners[type] || [];\n    listeners[type].push(fn);\n    return this;\n  };\n  \n  body.once = function(type, fn) {\n    var wrap = function(e) {\n      body.off(type, wrap);\n      return fn.call(this, e);\n    };\n    body.on(type, wrap);\n    return this;\n  };\n\n  body.off = function(type, fn) {\n    var fns = listeners[type];\n    if( fns )\n      for(var i;~(i = fns.indexOf(fn));) fns.splice(i, 1);\n    \n    return this;\n  };\n\n  body.fire = function(type, detail) {\n    if( type === 'error' && !(listeners[type] && isteners[type].length) )\n      return console.error('[routes] error', detail);\n    \n    (listeners[type] || []).forEach(function(listener) {\n      listener.call(this, {\n        type: type,\n        detail: detail || {}\n      });\n    });\n  };\n  \n  return body;\n}\n\n// class Routes\nfunction Routes(options) {\n  if( !(this instanceof Routes) ) throw new Error('illegal state: \\'new Routes()\\' instead of \\'Routes()\\'');\n  \n  options = options || {};\n  \n  var self = this;\n  var baseURL = '';\n  var router = Router('root'), request, response, hashroutes;\n  \n  //console.info('baseURL', baseURL);\n  \n  this.config = function(key, value) {\n    var o = options;\n    if( arguments.length === 1 ) return o(key);\n    if( value === null ) delete o[key];\n    else o[key] = value;\n    return this;\n  };\n  \n  this.base = function(url) {\n    if( !arguments.length ) return baseURL;\n    if( !url ) {\n      baseURL = '';\n      return this;\n    }\n    baseURL = path.dirname(path.resolve(url, 'index.html'));\n    //console.log('baseURL', baseURL);\n    return this;\n  };\n  \n  this.router = function(name) {\n    return Router(name);\n  };\n  \n  this.normalize = function(url) {\n    url = url.trim();\n    if( !url ) return baseURL;\n    if( url[0] === '/' ) return baseURL + url;\n    return normalize(url).fullpath;\n  };\n  \n  var exec = this.exec = function(requrl) {\n    //console.info('exec', requrl);\n    var parsed = normalize(requrl);\n    var hash = parsed.hash;\n    var query = parsed.search;\n    var url = parsed.pathname;\n    var fullpath = parsed.fullpath;\n    if( request && request.requestURL && fullpath === request.requestURL ) return;\n    \n    //console.log('exec', baseURL, requrl, url, url.indexOf(baseURL), parsed);\n    if( baseURL && url.startsWith(baseURL) ) {\n      url = url.substring(baseURL.length);\n    } else if( baseURL ){\n      return console.error('given url is not a sub url of base url \\'' + baseURL + '\\'');\n    }\n    \n    hashroutes = [];\n    request = {\n      method: 'get',\n      parsed: parsed,\n      baseURL: baseURL,\n      requestURL: fullpath,\n      url: url,\n      hashname: hash,\n      query: parseQuery(query),\n      params: {}\n    };\n    \n    response = {\n      redirect: function(tourl) {\n        //console.info('redirect', url, request.purl, request.url, request);\n        if( tourl.startsWith('#') ) {\n          location.href = tourl;\n        } else if( tourl.startsWith('/') ) {\n          exec(path.join(baseURL, tourl));\n        } else {\n          exec(path.join(baseURL, request.purl, request.url, tourl));\n        }\n        \n        router.fire('redirect', {\n          requestURL: fullpath,\n          url: url,\n          request: request,\n          response: response\n        });\n        \n        return this;\n      },\n      hash: function(hash, fn) {\n        hashroutes.push({hash:hash, fn:fn});\n      }\n    };\n    \n    router.fire('request', {\n      requestURL: fullpath,\n      url: url,\n      request: request,\n      response: response\n    });\n    \n    router(request, response);\n    return this;\n  };\n  \n  this.exechash = function() {\n    // TODO: hash 변경. 현재 request 의 hash 를 라우팅한다.\n    return this;\n  };\n  \n  // --- wire to router\n  this.use = function(uri, fn) {\n    router.use.apply(router, arguments);\n    return this;\n  };\n  \n  this.boot = function(fn) {\n    router.boot(fn);\n    return this;\n  };\n  \n  this.get = function(uri, fn) {\n    router.get(uri, fn);\n    return this;\n  };\n  \n  this.notfound = function(fn) {\n    router.notfound(fn);\n    return this;\n  };\n  \n  this.error = function(fn) {\n    router.error(fn);\n    return this;\n  };\n  \n  this.drop = function(fn) {\n    router.drop(fn);\n    return this;\n  };\n  \n  this.exists = function(uri) {\n    return router.exists(uri);\n  };\n  \n  this.clear = function() {\n    router.clear();\n    return this;\n  };\n  \n  this.on = function(type, fn) {\n    router.on(type, fn);\n    return this;\n  };\n  \n  this.once = function(type, fn) {\n    router.once(type, fn);\n    return this;\n  };\n  \n  this.off = function(type, fn) {\n    router.off(type, fn);\n    return this;\n  };\n}\n\nvar routes = new Routes();\nroutes.Routes = Routes;\nroutes.Router = Router;\n\n// instantiate main routes && trigger\n(function() {\n  //var always = config('routes.always') === 'true' ? true : true;\n  var mode = config('routes.mode') || (history.pushState ? 'pushstate' : 'hash');\n  \n  if( mode === 'pushstate' ) {\n    if( !history.pushState ) return console.error('[routes] unsupported \\'history.pushState\\'');\n    \n    var _pushState = history.pushState;\n    history.pushState = function(state, title, url) {\n      _pushState.apply(history, arguments);\n      routes.exec(location.href);\n    };\n    \n    window.onpopstate = function(e) {\n      routes.exec(location.href);\n    };\n    \n    routes.on('request', function(e) {\n      if( normalize(location.href).fullpath !== normalize(e.detail.requestURL).fullpath ) {\n        _pushState.call(history, null, null, e.detail.requestURL);\n      }\n    });\n    \n    routes.href = function(url) {\n      history.pushState(null, null, routes.normalize(url));\n    };\n  } else if( mode === 'hash' ) {\n    if( !('onhashchange' in window) ) return console.error('[routes] unsupported \\'onhashchange\\'');\n    \n    addEventListener(window, 'hashchange', function() {\n      routes.exec(location.hash);\n    });\n    \n    routes.on('redirect', function(e) {\n      location.href = '#' + e.detail.url;\n    });\n    \n    routes.href = function(url) {\n      location.href = '#' + routes.normalize(url);\n    };\n  }\n  \n  var observer;\n  function bootup() {\n    function routify(a) {\n      if( !a.__routes_managed__ ) {\n        a.__routes_managed__ = true;\n        addEventListener(a, 'click', function(e) {\n          e.preventDefault();\n          routes.href(a.getAttribute('href'));\n        });\n      }\n      return this;\n    }\n  \n    function scan() {\n      [].forEach.call(document.querySelectorAll('[routes], [data-routes]'), routify);\n      return this;\n    }\n    \n    // observe anchor tags\n    if( observer ) observer.disconnect();\n    observer = new MutationObserver(function(mutations) {\n      mutations.forEach(function(mutation) {\n        [].forEach.call(mutation.addedNodes, function(node) {\n          if( node.nodeType === 1 ) {\n            if( node.hasAttribute('routes') ) routify(node);\n            if( node.hasAttribute('data-routes') ) routify(node);\n            if( node.querySelectorAll ) [].forEach.call(node.querySelectorAll('[routes], [data-routes]'), routify);\n          }\n        });\n      });\n    });\n    \n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    scan();\n    routes.exec(location.href);\n  }\n  \n  if( document.body ) bootup();\n  else addEventListener(document, 'DOMContentLoaded', bootup);\n})();\n\nmodule.exports = routes;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./routes.js\n ** module id = 0\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}