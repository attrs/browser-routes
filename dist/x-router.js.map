{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 95300f19b93a5a3e35bd","webpack:///./lib/index.js","webpack:///(webpack)/~/node-libs-browser/~/path-browserify/index.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./~/route-pattern/route-pattern.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/index.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/decode.js","webpack:///(webpack)/~/node-libs-browser/~/querystring-es3/encode.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,+CAA+C;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qD;AACA,sD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,GAAE;;;;;AAKF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,GAAG;;AAEZ;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,uBAAuB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAA+C,gBAAgB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,uBAAsB;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,uBAAuB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gDAA+C,iBAAiB;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA,U;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;;AAET;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AC54BD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACtHtC;;AAEA;AACA;AACA;AACA,WAAU,WAAW,GAAG,KAAK,GAAG,KAAK,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB,qBAAoB;AACpB;AACA,2BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjXA;;AAEA;AACA;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"x-router.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Router\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Router\"] = factory();\n\telse\n\t\troot[\"Router\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 95300f19b93a5a3e35bd\n **/","var path = require('path');\nvar RoutePattern = require('route-pattern');\n\n/*\n(function() {\n  var defined = '/hello/:planet?foo=:foo&fruit=:fruit#:section';\n  var url = '/hello/earth?foo=bar&fruit=apple#chapter2';\n  var pattern = RoutePattern.fromString(defined);\n  var matches = pattern.matches(url);\n  var params = pattern.match(url);\n  \n  console.log('match', matches);\n  console.log(JSON.stringify(params, null, '  '));\n});\n*/\n\nvar a = document.createElement('a');\nfunction normalize(url) {\n  if( typeof url !== 'string' ) throw new TypeError('illegal url');\n  \n  a.href = url || '';\n  var fullpath = a.href;\n  fullpath = fullpath.substring(fullpath.indexOf('://') + 3);\n  if( !~fullpath.indexOf('/') ) fullpath = '/';\n  else fullpath = fullpath.substring(fullpath.indexOf('/'));\n  \n  var pathname = fullpath;\n  pathname = ~pathname.indexOf('?') ? pathname.substring(0, pathname.indexOf('?')) : pathname;\n  pathname = ~pathname.indexOf('#') ? pathname.substring(0, pathname.indexOf('#')) : pathname;\n  \n  return {\n    href: a.href,\n    protocol: a.protocol,\n    hostname: a.hostname,\n    port: a.port,\n    pathname: pathname,\n    fullpath: pathname + (a.search ? a.search : '') + (a.hash ? a.hash : ''),\n    search: a.search,\n    hash: a.hash,\n    host: a.host\n  };\n}\n\n\nfunction config(name, alt) {\n  var root = document.head.querySelector('meta[name=\\\"' + name + '\\\"][content]');\n  return (root && root.getAttribute('content')) || alt;\n}\n\nfunction endsWith(str, word) {\n  var i = str.toLowerCase().indexOf(word);\n  return i > 0 && i === str.length - word.length;\n}\n\nfunction parseQuery(query) {\n  query = query.trim();\n  if( query[0] === '?' ) query = query.substring(1);\n  var match,\n      pl     = /\\+/g,\n      search = /([^&=]+)=?([^&]*)/g,\n      decode = function (s) { return decodeURIComponent(s.replace(pl, ' ')); };\n      \n  var params = {};\n  while (match = search.exec(query)) {\n    var key = decode(match[1]);\n    var value = decode(match[2]);\n    if( Array.isArray(params[key]) ) params[key].push(value);\n    else if( params[key] ) (params[key] = [params[key]]).push(value);\n    else params[key] = value;\n  }\n  return params;\n}\n\nfunction defaultChecker() {\n  var tag = document.currentScript || document._currentScript;\n  return function() {\n    return tag && tag.ownerDocument && tag.ownerDocument.documentElement && tag.ownerDocument.documentElement.contains(tag);\n  };\n}\n\nfunction addEventListener(scope, type, fn, bubble) { \n  if( scope.attachEvent ) scope.attachEvent(type,fn); \n  else scope.addEventListener(type,fn,bubble);\n}\n\nfunction patternize(source, ignoresubdir) {\n  var pettern = RoutePattern.fromString(source);\n  var ap = RoutePattern.fromString(source + '/*after');\n  \n  return {\n    match: function(url) {\n      if( source === '/' ) return ignoresubdir ? true : (source === url);\n      \n      if( pettern.matches(url) ) {\n        return pettern.match(url).namedParams;\n      } else if( ignoresubdir && ap.matches(url) ) {\n        var params = ap.match(url).namedParams;\n        delete params.after;\n        return params;\n      }\n      return false;\n    },\n    matches: function(url) {\n      return pattern.matches(url) ? true : (ignoresubdir && ap.matches(url) ? true : false);\n    }\n  };\n}\n\nfunction dividepath(axis, full) {\n  if( axis[0] === '/' ) axis = axis.substring(1);\n  if( full[0] === '/' ) full = full.substring(1);\n  if( endsWith(axis, '/') ) axis = axis.substring(0, axis.length - 1);\n  if( endsWith(full, '/') ) full = full.substring(0, full.length - 1);\n  if( !axis ) return {\n    sub: '/' + full,\n    parent: '/'\n  };\n  \n  while(~axis.indexOf('//')) axis.split('//').join('/');\n  while(~full.indexOf('//')) full.split('//').join('/');\n  \n  axis = axis.split('/');\n  full = full.split('/');\n  var sub = [], parent = [];\n  \n  for(var i=0; i < full.length; i++) {\n    if( axis[i] && axis[i][0] !== ':' &&  full[i] !== axis[i] ) return null;\n    \n    if( i >= axis.length ) sub.push(full[i]);\n    else parent.push(full[i]);\n  }\n  \n  return {\n    parent: '/' + parent.join('/'),\n    sub: '/' + sub.join('/')\n  };\n}\n\n/*\nconsole.log('/', subpath('/', '/system/user/list'));\nconsole.log('/system', subpath('/system', '/system/user/list'));\nconsole.log('/system/user', subpath('/system/user', '/system/user/list'));\nconsole.log('/system/user/list', subpath('/system/user/list', '/system/user/list'));\nconsole.log('/:a', subpath('/:a', '/system/user/list'));\nconsole.log('/:a/:b', subpath('/:a/:b', '/system/user/list'));\nconsole.log('/:a/:b/:c', subpath('/:a/:b/:c', '/system/user/list'));\n\nvar p = patternize('/', true);\nconsole.log('/a/b/c', p.match('/a/b/c'));\n*/\n\nfunction capture(o) {\n  return JSON.parse(JSON.stringify(o));\n}\n\nfunction redirector(url) {\n  return function redirector(req, res, next) {\n    res.redirect(url);\n  };\n}\n\nfunction mix() {\n  var result = {};\n  [].forEach.call(arguments, function(o) {\n    if( o && typeof o === 'object' ) {\n      for(var k in o ) result[k] = o[k];\n    }\n  });\n  return result;\n}\n\nfunction EventObject(type, detail, src) {\n  this.type = type;\n  this.detail = detail || {};\n  this.src = src;\n}\n/*\nEventObject.prototype = {\n  preventDefault: function() {\n  },\n  stopPropagation: function() {\n  }\n};*/\n\n\n\n\n// factory Router\nfunction Router(id) {\n  id = id || (Math.random() + '') || 'unknwon';\n  var boot = true;\n  var routes = [];\n  var listeners = {};\n  var error;\n  \n  var body = function Router(req, res, onext) {\n    if( !req.url || req.url[0] !== '/' ) return console.error('[x-router] illegal state: url not defined in request: ', req.url);\n    error = null;\n    onext = onext || function() {};\n    \n    var oParentURL = req.parentURL || '';\n    var oURL = req.url;\n    var oParams = req.params || {};\n    var i = 0, finished = false;\n    \n    var next = function(err) {\n      if( finished ) return console.error('[x-router] next function twice called.', id, err);\n      finished = true;\n      \n      req.url = oURL;\n      req.parentURL = oParentURL;\n      req.params = oParams;\n      boot = false;\n      \n      if( err ) return body.fire('error', {\n        href: req.href,\n        url: req.url,\n        request: req,\n        response: res,\n        error: err\n      }) && onext(err);\n      \n      body.fire('notfound', {\n        href: req.href,\n        url: req.url,\n        request: req,\n        response: res\n      });\n      \n      onext();\n    };\n    \n    var forward = function(err) {\n      if( err ) return next(err);\n      \n      var route = routes[i++];\n      if( !route ) return next();\n      if( !boot && route.type === 'boot' ) return forward();\n      //console.log(route, boot, route.pattern, route.pattern.match(req.url));\n      \n      var params = route.pattern && route.pattern.match(req.url);\n      if( !params ) return forward();\n      \n      req.boot = boot;\n      req.params = oParams;\n      req.parentURL = oParentURL;\n      req.url = oURL;\n      \n      var div = dividepath(route.path || '', req.url);\n      req.params = mix(oParams, params);\n      \n      if( route.fn.__router__ ) {\n        req.url = div.sub;\n        req.parentURL = path.join(oParentURL, div.parent);\n        //req.parentURL = req.parentURL;\n        \n        /*console.log('routing', capture({\n          //type: type,\n          //id: route.fn.id,\n          path: route.path,\n          url: req.url,\n          parentURL: req.parentURL,\n          oParentURL: oParentURL,\n          oURL: oURL\n        }));*/\n        \n        route.fn.apply(body, [req, res, forward]);\n      } else {\n        route.fn.apply(body, [req, res, forward]);\n      }\n      \n      body.fire('route', {\n        routetype: route.type,\n        config: route,\n        parentURL: req.parentURL,\n        url: req.url,\n        href: path.join(req.baseURL, req.parentURL, req.url),\n        fn: route.fn,\n        params: params,\n        boot: boot,\n        request: req,\n        response: res\n      });\n    };\n    forward();\n  };\n  \n  var adaptchild = function(fn) {\n    if( fn.__router__ && fn.on && fn.fire ) {\n      fn.on('route', function(e) {\n        body.fire(e);\n      });\n    }\n    \n    return fn;\n  };\n  \n  body.id = id;\n  body.__router__ = true;\n  body.exists = function(url) {\n    var exists = false;\n    routes.forEach(function(route) {\n      if( exists ) return;\n      if( route.type === 'get' ) {\n        var params = route.pattern.match(url);\n        if( params ) exists = true;\n      } else if( route.type === 'use' ) {\n        exists = route.fn.exists(url.substring(route.path.length));\n      }\n    });\n    return exists;\n  };\n  \n  body.use = function(path, fn) {\n    if( typeof path === 'function' ) fn = path, path = '/';\n    if( typeof path !== 'string' ) throw new TypeError('illegal type of path:' + typeof(path));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    path = path ? path.trim() : '/';\n    if( path[0] !== '/' ) path = '/' + path;\n    \n    routes.push({\n      type: 'use',\n      path: path,\n      pattern: patternize(path, true),\n      fn: adaptchild(fn)\n    });\n    return this;\n  };\n  \n  body.get = function(path, fn) {\n    if( typeof path === 'function' ) fn = path, path = '/';\n    if( typeof path !== 'string' ) throw new TypeError('illegal type of path:' + typeof(path));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    path = path ? path.trim() : '/';\n    if( path[0] !== '/' ) path = '/' + path;\n    \n    routes.push({\n      type: 'get',\n      path: path,\n      pattern: patternize(path),\n      fn: adaptchild(fn)\n    });\n    return this;\n  };\n  \n  body.boot = function(path, fn) {\n    if( typeof path === 'function' ) fn = path, path = '/';\n    if( typeof path !== 'string' ) throw new TypeError('illegal type of path:' + typeof(path));\n    if( typeof fn === 'string' ) fn = redirector(fn);\n    if( typeof fn !== 'function' ) throw new TypeError('illegal type of router:' + typeof(fn));\n    path = path ? path.trim() : '/';\n    if( path[0] !== '/' ) path = '/' + path;\n    \n    routes.push({\n      type: 'boot',\n      path: path,\n      pattern: patternize(path, true),\n      fn: adaptchild(fn)\n    });\n    return this;\n  };\n  \n  body.notfound = function(fn) {\n    body.on('notfound', fn);\n    return this;\n  };\n  \n  body.error = function(fn) {\n    body.on('error', fn);\n    return this;\n  };\n  \n  body.drop = function(fn) {\n    var dropfns = [];\n    routes.forEach(function(route) {\n      if( route.fn === fn ) dropfns.push(route);\n    });\n    \n    dropfns.forEach(function(route) {\n      routes.splice(routes.indexOf(route), 1);\n    });\n    return this;\n  };\n  \n  body.clear = function() {\n    routes = [];\n    return this;\n  };\n  \n  body.on = function(type, fn) {\n    listeners[type] = listeners[type] || [];\n    listeners[type].push(fn);\n    return this;\n  };\n  \n  body.once = function(type, fn) {\n    var wrap = function(e) {\n      body.off(type, wrap);\n      return fn.call(this, e);\n    };\n    body.on(type, wrap);\n    return this;\n  };\n\n  body.off = function(type, fn) {\n    var fns = listeners[type];\n    if( fns )\n      for(var i;~(i = fns.indexOf(fn));) fns.splice(i, 1);\n    \n    return this;\n  };\n\n  body.fire = function(type, detail) {\n    var event;\n    if( typeof type === 'string' ) {\n      event = new EventObject(type, detail, body);\n      event.srcRouter = body;\n    } else if( type instanceof EventObject ) {\n      event = type;\n    } else {\n      return console.error('[x-router] illegal arguments, type is must be a string or event', type);\n    }\n    \n    event.router = body;\n    var action = function(listener) {\n      listener.call(this, event);\n    };\n    \n    (listeners['*'] || []).forEach(action);\n    (listeners[event.type] || []).forEach(action);\n    \n    return this;\n  };\n  \n  body.hasListener = function(type) {\n    return listeners[type] && listeners[type].length ? true : false;\n  };\n  \n  return body;\n}\n\n// class Application\nfunction Application(options) {\n  var baseURL = '';\n  var router = Router('root'), hashrouter, request, response;\n  var session = {};\n  var timeout, referer;\n  \n  Application.apps.push(router);\n  \n  router.timeout = function(msec) {\n    if( typeof msec !== 'number' ) return console.warn('illegal timeout ' + msec);\n    timeout = msec;\n  };\n  \n  router.base = function(url) {\n    if( !arguments.length ) return baseURL;\n    if( !url ) {\n      baseURL = '';\n      return this;\n    }\n    baseURL = path.dirname(path.resolve(url, 'index.html'));\n    return this;\n  };\n  \n  router.router = function(name) {\n    return Router(name);\n  };\n  \n  router.fullhref = function(url) {\n    url = url.trim();\n    if( !url ) url = baseURL;\n    else if( url[0] === '/' ) url = baseURL + url;\n    else if( !request ) url = baseURL + '/' + url;\n    else if( request.href ) url = path.dirname(request.href) + '/' + url;\n    else console.error('cannot resolve href', url);\n    \n    return normalize(url.split('//').join('/')).fullpath;\n  };\n  \n  router.hash = function(hash, next) {\n    request.hash = hash || '';\n    hashrouter(request, response, next);\n    return this;\n  };\n  \n  router.href = function(href, body, options) {\n    if( typeof body === 'boolean' ) options = {writestate:body}, body = null;\n    href = href || '';\n    \n    var parsed = normalize(router.fullhref(href));\n    var url = parsed.pathname;\n    if( url.indexOf(baseURL) !== 0 )\n      return console.error('given href \\'' + url + '\\' is not a sub url of base url \\'' + baseURL + '\\'');\n    url = url.substring(baseURL.length);\n    \n    //console.log('href', arguments[0], url);\n    \n    if( request && request.href === parsed.fullpath ) return;\n    if( typeof options === 'boolean' ) options = {writestate:options};\n    if( !options || typeof options !== 'object' ) options = {};\n    \n    hashrouter = Router('hash');\n    request = router.request = {\n      app: router,\n      referer: referer,\n      method: 'get',\n      parsed: parsed,\n      baseURL: baseURL,\n      href: parsed.fullpath,\n      url: url || '/',\n      options: options,\n      hashname: parsed.hash,\n      query: parseQuery(parsed.search),\n      params: {},\n      body: body || {},\n      session: session\n    };\n    \n    //console.log('req', capture(request));\n    \n    var finished = false;\n    response = router.response = {\n      redirect: function(to, body, options) {\n        finished = true;\n        options = options || {};\n        options.redirect = true;\n        body = body || request.body || {};\n        \n        if( to[0] !== '#' && to[0] !== '/' ) {\n          to = path.join(request.parentURL, request.url, to);\n        }\n        \n        router.fire('redirect', {\n          options: options,\n          referer: (referer = normalize(path.join(request.baseURL, request.url)).href),\n          to: to,\n          requested: arguments[0],\n          request: request,\n          response: response\n        });\n        \n        router.href(to, body, options);\n        return this;\n      },\n      hash: function(hash, fn) {\n        hashrouter.get('#' + hash, fn);\n        return this;\n      },\n      exechash: function(hash, done) {\n        router.exechash(req.hash, done);\n        return this;\n      },\n      end: function(exechash) {\n        if( finished ) return console.warn('[x-router] request \\'' + request.href + '\\' already finished.');\n        finished = true;\n        \n        var fire = function(err) {\n          router.fire('end', {\n            href: parsed.fullpath,\n            url: url,\n            error: err,\n            request: request,\n            response: response\n          });\n        };\n        \n        if( !err && exechash !== false ) router.exechash(req.hash, fire);\n        else fire(router.error);\n      }\n    };\n    \n    if( timeout > 0 ) {\n      setTimeout(function() {\n        if( finished ) return;\n        console.warn('[x-router] router timeout(' + timeout + ')');\n        response.end();\n      }, timeout);\n    }\n    \n    router.fire('request', {\n      href: parsed.fullpath,\n      url: url,\n      request: request,\n      response: response\n    });\n    \n    if( options.writestate !== false && options.replacestate !== true && options.redirect !== true ) {\n      referer = parsed.fullpath;\n    }\n    \n    router(request, response, function(err) {\n      if( err ) return router.fire('error', {\n        href: parsed.fullpath,\n        url: url,\n        request: request,\n        response: response,\n        error: err\n      });\n      \n      router.fire('notfound', {\n        href: parsed.fullpath,\n        url: url,\n        request: request,\n        response: response\n      });\n    });\n    return this;\n  };\n  \n  router.on('*', function(e) {\n    e.app = router;\n    Application.fire(e);\n  });\n  \n  return router;\n};\n\n// initialize context feature\n(function() {\n  var currentapp, apps = [], listeners = {};\n  \n  var current = function(app) {\n    if( !arguments.length ) return currentapp || apps[0];\n    if( !~apps.indexOf(app) ) return console.error('[x-router] not defined app', app);\n    currentapp = app;\n    return this;\n  };\n  \n  var href = function() {\n    var app = current();\n    if( !app ) return console.error('[x-router] not yet initialized');\n    app.href.apply(currentapp, arguments);\n  };\n  \n  var on = function(type, fn) {\n    listeners[type] = listeners[type] || [];\n    listeners[type].push(fn);\n    return this;\n  };\n  \n  var once = function(type, fn) {\n    var wrap = function(e) {\n      off(type, wrap);\n      return fn.call(Application, e);\n    };\n    on(type, wrap);\n    return this;\n  };\n\n  var off = function(type, fn) {\n    var fns = listeners[type];\n    if( fns )\n      for(var i;~(i = fns.indexOf(fn));) fns.splice(i, 1);\n    \n    return this;\n  };\n\n  var fire = function(event) {\n    var action = function(listener) {\n      listener.call(this, event);\n    };\n    \n    (listeners['*'] || []).forEach(action);\n    (listeners[event.type] || []).forEach(action);\n    \n    return this;\n  };\n  \n  Application.apps = apps;\n  Application.Router = Router;\n  Application.current = current;\n  Application.href = href;\n  Application.on = on;\n  Application.once = once;\n  Application.off = off;\n  Application.fire = fire;\n  \n  // @deprecated\n  //Application.router = Router;\n})();\n\nmodule.exports = Application;\n\n// instantiate main routes && trigger\n(function() {\n  var mode = config('x-router.mode') || (history.pushState ? 'pushstate' : 'hash');\n  if( !~['pushstate', 'hash', 'none'].indexOf(mode) ) {\n    console.error('[x-router] unsupported mode: ' + mode);\n    mode = history.pushState ? 'pushstate' : 'hash';\n  }\n  \n  var app = function() {\n    return Application.current() || {\n      href:function() {\n        console.error('[x-router] not yet initialized');\n      }\n    };\n  };\n  \n  var validatelocation = function(href) {\n    var base = app().base() || '';\n    href = normalize(href || location.href).fullpath;\n    if( !href.indexOf(base) ) return href.substring(base.length);\n    return href;\n  }\n  \n  if( mode === 'pushstate' ) {\n    if( !history.pushState ) return console.error('[x-router] browser does not support \\'history.pushState\\'');\n    \n    var pushState = history.pushState;\n    var replaceState = history.replaceState;\n    \n    history.pushState = function(state, title, href) {\n      pushState.apply(history, arguments);\n      app().href(validatelocation(), state);\n    };\n    \n    history.replaceState = function(state, title, href) {\n      replaceState.apply(history, arguments);\n      app().href(validatelocation(), state, {\n        replacestate: true\n      });\n    };\n    \n    window.onpopstate = function(e) {\n      app().href(validatelocation(), e.state, {writestate:false});\n    };\n    \n    var push = function(href, body) {\n      pushState.call(history, body, null, href);\n    };\n    \n    var replace = function(href, body) {\n      replaceState.call(history, body, null, href);\n    };\n    \n    Application.on('request', function(e) {\n      if( app() !== e.app ) return;\n      var href = e.detail.href;\n      var body = e.detail.request.body;\n      var o = e.detail.request.options;\n      if( o.writestate === false ) return;\n      if( o.replacestate || o.redirect ) replace(href, body);\n      else push(href, body);\n    });\n    \n    Application.on('end', function(e) {\n      if( app() !== e.app ) return;\n      var href = e.detail.href;\n      var body = e.detail.request.body;\n      var o = e.detail.request.options;\n      if( o.writestate === false ) return;\n      replace(href, body);\n    });\n    \n    Application.on('route', function(e) {\n      if( app() !== e.app ) return;\n      //console.info('route', e.detail.href);\n      \n      /*var href = e.detail.href;\n      var body = e.detail.request.body;\n      var o = e.detail.request.options;\n      if( o.writestate === false ) return;\n      replace(href, body);*/\n    });\n  } else if( mode === 'hash' ) {\n    addEventListener(window, 'hashchange', function() {\n      //console.log('hashchange', location.hash);\n      if( location.hash.length >= 1 ) app().href(location.hash.substring(1));\n    });\n    \n    var replace = function(url, body) {\n      location.replace('#' + url);\n    };\n    \n    var push = function(url, body) {\n      location.assign('#' + url);\n    };\n    \n    Application.on('request', function(e) {\n      if( app() !== e.app ) return;\n      var url = e.detail.url;\n      var body = e.detail.request.body;\n      var o = e.detail.request.options;\n      if( o.writestate === false ) return;\n      if( o.replacestate || o.redirect ) replace(url, body);\n      else push(url, body);\n    });\n    \n    Application.on('end', function(e) {\n      if( app() !== e.app ) return;\n      var url = e.detail.url;\n      var body = e.detail.request.body;\n      var o = e.detail.request.options;\n      if( o.writestate === false ) return;\n      replace(url, body);\n    });\n  }\n  \n  var ie = (function(){\n    var undef,\n        v = 3,\n        div = document.createElement('div'),\n        all = div.getElementsByTagName('i');\n        \n    while(div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',all[0]);\n    return v > 4 ? v : undef;\n  }());\n  \n  var observer;\n  function bootup() {\n    function routify(a) {\n      if( !a.__xrouter__ ) {\n        a.__xrouter__ = true;\n        \n        a.onroute = null;\n        a.onrouteresponse = null;\n        a.onrouterequest = null;\n        \n        if( ie <= 8 ) {\n          a.onclick = function(e) {\n            var ghost = a.hasAttribute('data-ghost') || a.hasAttribute('ghost');\n            var href = a.getAttribute('data-href') || a.getAttribute('href');\n            var p = href.indexOf(':'), s = href.indexOf('/');\n            \n            if( !href || (~p && p < s) ) return;\n            \n            app().href(href, null, {\n              writestate: ghost ? false : true\n            });\n            \n            return false;\n          };\n        } else {\n          a.onclick = function(e) {\n            var ghost = a.hasAttribute('data-ghost') || a.hasAttribute('ghost');\n            var href = a.getAttribute('data-href') || a.getAttribute('href');\n            var p = href.indexOf(':'), s = href.indexOf('/');\n            \n            if( !href || (~p && p < s) ) return;\n            e.preventDefault();\n            \n            app().href(href, null, {\n              writestate: ghost ? false : true\n            });\n          };\n        } \n      }\n      return this;\n    }\n    \n    var routeselector = '*[route], *[data-route], *[routes], *[data-routes]';\n    function scan() {\n      [].forEach.call(document.querySelectorAll(routeselector), routify);\n      return this;\n    }\n    \n    scan();\n    \n    if( mode === 'pushstate' ) app().href(validatelocation());\n    else if( mode === 'hash' ) app().href(location.hash.substring(1));\n    \n    // observe anchor tags\n    if( config('observe') !== 'false' ) {\n      if( window.MutationObserver ) {\n        if( observer ) observer.disconnect();\n        observer = new MutationObserver(function(mutations) {\n          mutations.forEach(function(mutation) {\n            [].forEach.call(mutation.addedNodes, function(node) {\n              if( node.nodeType === 1 ) {\n                if( node.hasAttribute('route') || node.hasAttribute('routes') ) routify(node);\n                if( node.hasAttribute('data-route') || node.hasAttribute('data-routes') ) routify(node);\n                if( node.querySelectorAll ) [].forEach.call(node.querySelectorAll(routeselector), routify);\n              }\n            });\n          });\n        });\n      \n        observer.observe(document.body, {\n          childList: true,\n          subtree: true\n        });\n      } else {\n        window.setInterval(scan, 1000);\n      }\n    }\n  }\n  \n  if( document.body ) bootup();\n  else {\n    if( document.addEventListener ) {\n      document.addEventListener('DOMContentLoaded', function() {\n        window.setTimeout(bootup,1);\n      });\n    } else if( document.attachEvent ) {\n      document.attachEvent('onreadystatechange', function () {\n        if( document.readyState === 'complete' ) window.setTimeout(bootup,1);\n      });\n    }\n  };\n  \n  window.route = function() {\n    var current = app();\n    current.href.apply(current, arguments);\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","var querystring = require(\"querystring\");\n\n// # Utility functions\n//\n// ## Shallow merge two or more objects, e.g.\n// merge({a: 1, b: 2}, {a: 2}, {a: 3}) => {a: 3, b: 2}\nfunction merge() {\n  return [].slice.call(arguments).reduce(function (merged, source) {\n    for (var prop in source) {\n      merged[prop] = source[prop];\n    }\n    return merged;\n  }, {});\n}\n\n// Split a location string into different parts, e.g.:\n// splitLocation(\"/foo/bar?fruit=apple#some-hash\") => {\n//  path: \"/foo/bar\", queryString: \"fruit=apple\", hash: \"some-hash\" \n// }\nfunction splitLocation(location) {\n  var re = /([^\\?#]*)?(\\?[^#]*)?(#.*)?$/;\n  var match = re.exec(location);\n  return {\n    path: match[1] || '',\n    queryString: match[2] && match[2].substring(1) || '',\n    hash: match[3] && match[3].substring(1) || ''\n  }\n}\n\n// # QueryStringPattern\n// The QueryStringPattern holds a compiled version of the query string part of a route string, i.e.\n// ?foo=:foo&fruit=:fruit\nvar QueryStringPattern = (function () {\n\n  // The RoutePattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function QueryStringPattern(options) {\n\n    // The query parameters specified\n    this.params = options.params;\n\n    // if allowWildcards is set to true, unmatched query parameters will be ignored\n    this.allowWildcards = options.allowWildcards;\n\n    // The original route string (optional)\n    this.routeString = options.routeString;\n  }\n\n  QueryStringPattern.prototype.matches = function (queryString) {\n    var givenParams = (queryString || '').split(\"&\").reduce(function (params, pair) {\n      var parts = pair.split(\"=\"),\n        name = parts[0],\n        value = parts[1];\n      if (name) params[name] = value;\n      return params;\n    }, {});\n\n    var requiredParam, requiredParams = [].concat(this.params);\n    while (requiredParam = requiredParams.shift()) {\n      if (!givenParams.hasOwnProperty(requiredParam.key)) return false;\n      if (requiredParam.value && givenParams[requiredParam.key] != requiredParam.value) return false;\n    }\n    if (!this.allowWildcards && this.params.length) {\n      if (Object.getOwnPropertyNames(givenParams).length > this.params.length) return false;\n    }\n    return true;\n  };\n\n  QueryStringPattern.prototype.match = function (queryString) {\n\n    if (!this.matches(queryString)) return null;\n\n    var data = {\n      params: [],\n      namedParams: {},\n      namedQueryParams: {}\n    };\n\n    if (!queryString) {\n      return data;\n    }\n\n    // Create a mapping from each key in params to their named param\n    var namedParams = this.params.reduce(function (names, param) {\n      names[param.key] = param.name;\n      return names;\n    }, {});\n\n    var parsedQueryString = querystring.parse(queryString);\n    Object.keys(parsedQueryString).forEach(function(key) {\n      var value = parsedQueryString[key];\n      data.params.push(value);\n      if (namedParams[key]) {\n        data.namedQueryParams[namedParams[key]] = data.namedParams[namedParams[key]] = value;\n      }\n    });\n    return data;\n  };\n\n  QueryStringPattern.fromString = function (routeString) {\n\n    var options = {\n      routeString: routeString,\n      allowWildcards: false,\n      params: []\n    };\n\n    // Extract named parameters from the route string\n    // Construct an array with some metadata about each of the named parameters\n    routeString.split(\"&\").forEach(function (pair) {\n      if (!pair) return;\n\n      var parts = pair.split(\"=\"),\n        name = parts[0],\n        value = parts[1] || '';\n\n      var wildcard = false;\n\n      var param = { key: name };\n\n      // Named parameters starts with \":\"\n      if (value.charAt(0) == ':') {\n        // Thus the name of the parameter is whatever comes after \":\"\n        param.name = value.substring(1);\n      }\n      else if (name == '*' && value == '') {\n        // If current param is a wildcard parameter, the options are flagged as accepting wildcards\n        // and the current parameter is not added to the options' list of params\n        wildcard = options.allowWildcards = true;\n      }\n      else {\n        // The value is an exact match, i.e. the route string \n        // page=search&q=:query will match only when the page parameter is \"search\"\n        param.value = value;\n      }\n      if (!wildcard) {\n        options.params.push(param);\n      }\n    });\n    return new QueryStringPattern(options);\n  };\n\n  return QueryStringPattern;\n})();\n\n// # PathPattern\n// The PathPattern holds a compiled version of the path part of a route string, i.e.\n// /some/:dir\nvar PathPattern = (function () {\n\n  // These are the regexps used to construct a regular expression from a route pattern string\n  // Based on route patterns in Backbone.js\n  var\n    pathParam = /:\\w+/g,\n    splatParam = /\\*\\w+/g,\n    namedParams = /(:[^\\/\\.]+)|(\\*\\w+)/g,\n    subPath = /\\*/g,\n    escapeRegExp = /[-[\\]{}()+?.,\\\\^$|#\\s]/g;\n\n  // The PathPattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function PathPattern(options) {\n    // The route string are compiled to a regexp (if it isn't already)\n    this.regexp = options.regexp;\n\n    // The query parameters specified in the path part of the route\n    this.params = options.params;\n\n    // The original routestring (optional)\n    this.routeString = options.routeString;\n  }\n\n  PathPattern.prototype.matches = function (pathname) {\n    return this.regexp.test(pathname);\n  };\n\n  // Extracts all matched parameters\n  PathPattern.prototype.match = function (pathname) {\n\n    if (!this.matches(pathname)) return null;\n    \n    // The captured data from pathname\n    var data = {\n      params: [],\n      namedParams: {}\n    };\n\n    // Using a regexp to capture named parameters on the pathname (the order of the parameters is significant)\n    (this.regexp.exec(pathname) || []).slice(1).forEach(function (value, idx) {\n      if(value !== undefined) {\n        value = decodeURIComponent(value);\n      }\n\n      data.namedParams[this.params[idx]] = value;\n      data.params.push(value);\n    }, this);\n\n    return data;\n  };\n\n  PathPattern.routePathToRegexp = function (path) {\n    path = path\n      .replace(escapeRegExp, \"\\\\$&\")\n      .replace(pathParam, \"([^/]+)\")\n      .replace(splatParam, \"(.*)?\")\n      .replace(subPath, \".*?\")\n      .replace(/\\/?$/, \"/?\");\n    return new RegExp(\"^/?\" + path + \"$\");\n  };\n\n  // This compiles a route string into a set of options which a new PathPattern is created with \n  PathPattern.fromString = function (routeString) {\n\n    // Whatever comes after ? and # is ignored\n    routeString = routeString.split(/\\?|#/)[0];\n\n    // Create the options object\n    // Keep the original routeString and a create a regexp for the pathname part of the url\n    var options = {\n      routeString: routeString,\n      regexp: PathPattern.routePathToRegexp(routeString),\n      params: (routeString.match(namedParams) || []).map(function (param) {\n        return param.substring(1);\n      })\n    };\n\n    // Options object are created, now instantiate the PathPattern\n    return new PathPattern(options);\n  };\n\n  return PathPattern;\n}());\n\n// # RegExpPattern\n// The RegExpPattern is just a simple wrapper around a regex, used to provide a similar api as the other route patterns\nvar RegExpPattern = (function () {\n  // The RegExpPattern constructor\n  // Wraps a regexp and provides a *Pattern api for it\n  function RegExpPattern(regex) {\n    this.regex = regex;\n  }\n\n  RegExpPattern.prototype.matches = function (loc) {\n    return this.regex.test(loc);\n  };\n\n  // Extracts all matched parameters\n  RegExpPattern.prototype.match = function (location) {\n\n    if (!this.matches(location)) return null;\n\n    var loc = splitLocation(location);\n\n    return {\n      params: this.regex.exec(location).slice(1),\n      queryParams: querystring.parse(loc.queryString),\n      namedParams: {}\n    };\n  };\n\n  return RegExpPattern;\n}());\n\n// # RoutePattern\n// The RoutePattern combines the PathPattern and the QueryStringPattern so it can represent a full location\n// (excluding the scheme + domain part)\n// It also allows for having path-like routes in the hash part of the location\n// Allows for route strings like:\n// /some/:page?param=:param&foo=:foo#:bookmark\n// /some/:page?param=:param&foo=:foo#/:section/:bookmark\n// \n// Todo: maybe allow for parameterization of the kind of route pattern to use for the hash?\n// Maybe use the QueryStringPattern for cases like\n// /some/:page?param=:param&foo=:foo#?onlyCareAbout=:thisPartOfTheHash&*\n// Need to test how browsers handles urls like that\nvar RoutePattern = (function () {\n\n  // The RoutePattern constructor\n  // Takes a route string or regexp as parameter and provides a set of utility functions for matching against a \n  // location path\n  function RoutePattern(options) {\n    // The route string are compiled to a regexp (if it isn't already)\n    this.pathPattern = options.pathPattern;\n    this.queryStringPattern = options.queryStringPattern;\n    this.hashPattern = options.hashPattern;\n\n    // The original routestring (optional)\n    this.routeString = options.routeString;\n  }\n\n  RoutePattern.prototype.matches = function (location) {\n    // Whatever comes after ? and # is ignored\n    var loc = splitLocation(location);\n\n    return (!this.pathPattern || this.pathPattern.matches(loc.path)) &&\n      (!this.queryStringPattern || this.queryStringPattern.matches(loc.queryString) ) &&\n      (!this.hashPattern || this.hashPattern.matches(loc.hash))\n  };\n\n  // Extracts all matched parameters\n  RoutePattern.prototype.match = function (location) {\n\n    if (!this.matches(location)) return null;\n\n    // Whatever comes after ? and # is ignored\n    var loc = splitLocation(location),\n      match,\n      pattern;\n\n    var data = {\n      params: [],\n      namedParams: {},\n      pathParams: {},\n      queryParams: querystring.parse(loc.queryString),\n      namedQueryParams: {},\n      hashParams: {}\n    };\n\n    var addMatch = function (match) {\n      data.params = data.params.concat(match.params);\n      data.namedParams = merge(data.namedParams, match.namedParams);\n    };\n\n    if (pattern = this.pathPattern) {\n      match = pattern.match(loc.path);\n      if (match) addMatch(match);\n      data.pathParams = match ? match.namedParams : {};\n    }\n    if (pattern = this.queryStringPattern) {\n      match = pattern.match(loc.queryString);\n      if (match) addMatch(match);\n      data.namedQueryParams = match ? match.namedQueryParams : {};\n    }\n    if (pattern = this.hashPattern) {\n      match = pattern.match(loc.hash);\n      if (match) addMatch(match);\n      data.hashParams = match ? match.namedParams : {};\n    }\n    return data;\n  };\n\n  // This compiles a route string into a set of options which a new RoutePattern is created with \n  RoutePattern.fromString = function (routeString) {\n    var parts = splitLocation(routeString);\n\n    var matchPath = parts.path;\n    var matchQueryString = parts.queryString || routeString.indexOf(\"?\") > -1;\n    var matchHash = parts.hash || routeString.indexOf(\"#\") > -1;\n\n    // Options object are created, now instantiate the RoutePattern\n    return new RoutePattern({\n      pathPattern: matchPath && PathPattern.fromString(parts.path),\n      queryStringPattern: matchQueryString && QueryStringPattern.fromString(parts.queryString),\n      hashPattern: matchHash && PathPattern.fromString(parts.hash),\n      routeString: routeString\n    });\n  };\n\n  return RoutePattern;\n}());\n\n// CommonJS export\nmodule.exports = RoutePattern;\n\n// Also export the individual pattern classes\nRoutePattern.QueryStringPattern = QueryStringPattern;\nRoutePattern.PathPattern = PathPattern;\nRoutePattern.RegExpPattern = RegExpPattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/route-pattern/route-pattern.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/index.js\n ** module id = 4\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/decode.js\n ** module id = 5\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/querystring-es3/encode.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}